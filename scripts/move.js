// Hello traveller
// Do not edit this file
// I know you think you've got some good reason that I didn't think of,
//   but be prepared to spend days debugging anything you change
// here there be dragons

// (editing Tracer is maybe acceptable. touch nothing else)

// Are you trying to add multiple exits to rooms? That's a very very
//   bad idea - where tf are you gonna store the "openingStack" that
//   keeps track of which nested openings you're in?
//   Just redesign the level so that the openings align - like
//   what you did by adding the orange room to DOLPHIN

// Running tally of times this seal has been disregarded and the result was good:
//   |
// Running tally of times this seal has been disregarded and the result was bad:
//

class Tracer {
  static indent_str = "  "
  constructor(silent) {
    this.indent = 0
    this.silent = silent
  }

  tracify(fxn) {
    const wrapped = (...args) => {
      this.enter(fxn.name, args)
      const ret = fxn(...args)
      this.exit(fxn.name, args, ret)
      return ret
    }
    Object.defineProperty(wrapped, "name", { value: fxn.name })
    return wrapped
  }

  toggle() {
    this.silent = !this.silent
  }

  // main fxnality
  printSignature(name, args) {
    const parts = []
    parts.push(`${name}(`)
    for (const a of args) {
      if (a.str) {
        parts.push(`${a.str()}, `)
      } else {
        parts.push(`${serialize(a)}, `)
      }
    }
    parts.push(")")
    return parts.join('')
  }
  enter(name, args) {
    this.print(`-> ${this.printSignature(name, args)}`)
    this.changeIndent(1)
  }
  exit(name, args, ret) {
    this.changeIndent(-1)
    this.print(`${ret} <- ${this.printSignature(name, args)}`)
  }
  changeIndent(di) {
    this.indent += di
    assert(this.indent >= 0)
  }
  print(msg) {
    if (this.silent) return
    const parts = []
    for (let i = 0; i < this.indent; i++) {
      parts.push(Tracer.indent_str)
    }
    parts.push(msg)
    console.log(parts.join(''))
  }
}
const tracer = new Tracer()
tracer.toggle()

function arrEqual(a1, a2) {
  assert(a1.length === a2.length)
  for (let i = 0; i < a1.length; i += 1) {
    if (a1[i] !== a2[i]) return false
  }
  return true
}

let pushCache = new Map()
function resetPushableCache() {
  pushCache = new Map()
}
function pushableCached(fxn, altFxn) {
  const wrapped = (that, ...args) => {
    let hashArgs = [that, that.pos.x, that.pos.y, ...args]
    let entries = pushCache.get(fxn.name)
    if (!entries) {
      entries = []
      pushCache.set(fxn.name, entries)
    }
    let foundMatch = false
    for (const pastArgs of entries) {
      assert(pastArgs.length === hashArgs.length)
      if (arrEqual(hashArgs, pastArgs)) foundMatch = true
    }
    if (foundMatch) return altFxn(that, ...args)
    entries.push([...hashArgs]) // need to do this _before_ calling fxn, b/c its recursive
    return fxn(that, ...args)
  }
  Object.defineProperty(wrapped, "name", { value: fxn.name })
  return wrapped
}
RegisterTest("pushCache", () => {
  const divertedResults = []
  function spy(that, x, y) { assert(that); const res = 10*x+y; divertedResults.push(res); return res }

  let callCount = 0
  function foo_(that, x, y) { assert(that); callCount += 1; return 10*x + y }
  const foo = pushableCached(foo_, spy)

  const that = {pos: {x:10, y:20}}
  assertEqual(callCount, 0)
  assertEqual(foo(that, 1, 2), 12)
  assertEqual(divertedResults.length, 0)
  assertEqual(callCount, 1)

  assertEqual(foo(that, 3, 4), 34)
  assertEqual(divertedResults.length, 0)
  assertEqual(callCount, 2)

  assertEqual(foo(that, 3, 4), 34)
  assertEqual(divertedResults.length, 1)
  assertEqual(callCount, 2) // didnt increment
  assertEqual(divertedResults[0], 34) // routed to the alternate function

  that.pos.x = 9
  assertEqual(foo(that, 3, 4), 34)
  assertEqual(divertedResults.length, 1) // didnt divert
  assertEqual(callCount, 3) // incremented again

  resetPushableCache()
})

function cullInfinite(that) {
  // console.log("gone:", that);
  assert(that)
  PlayAndRecordSound(sndDestroy)
  that.die()
  return true // `that` was able to move,, into the infinite abyss
}

function buildRet(that, successCb, failCb) {
  return (b) => {
    if (b) {
      if (!findActorUnderMe([Crate, Mini, Player], that)) {
        successCb()
        return true
      } else {
        successCb()
        // console.warn("advanced NEW surprise", that.dead)
        return cullInfinite(that)
        // ^ this catches some cases during infbug and infbug2
      }
    }
    failCb()
    return false
  }
}

// DRY without subclassing for pushable objects
// maybeX means:
//   try to do X
//   if you did X, return true
//   if you couldn't do X, revert all changed state and return false
//
// Do each of these steps, aborting when the
// * optimistically move in the given direction (might have to revert later)
// * maybe teleport out
// * check if im in a wall
// * maybe teleport in
// * see if I'm on top of something i should have pushed
//   * try eating it, if i'm a mini
//   * try pushing it
// * succeed!
function maybePushableUpdate_(that, dir) {
  assert(that.frameStack)

  const oldPos = that.pos
  const oldFrameStack = that.frameStack // might change during e.g. maybeteleout; idk
  const r = buildRet(that, ()=>that.playMoveSound(), ()=> {
    that.setPos(oldPos)
    that.setFrameStack(oldFrameStack)
  })
  that.setPos(that.pos.addDir(dir)) // do this early; we'll undo it later if we need to

  // if (that.pos.equals(new RoomPos(Room.findName("Orange"), 7, 4))) {
  //   debugger;
  // }

  if (maybeTeleOut(that, dir)) return r(true)
  if (!CanMoveToTile(that.pos)) return r(false)
  if (maybeTeleIn(that, dir)) return r(true)

  let numIters = 0
  for (const cst of [Crate, Mini, Player]) {
    const toPush = findActorUnderMe(cst, that)
    if (!toPush) continue
    numIters += 1
    // how can toPush be a mini if we already called maybeTeleIn?
    // well, if there was either no opening, or we failed to get into the opening
    if (lifted(that, toPush, ()=>maybeConsume(that, toPush, dir))) return r(true)
    if (lifted(that, toPush, ()=>!maybePushableUpdate(toPush, dir))) return r(false)
    const surprise = findActorUnderMe([Crate, Mini, Player], that)
    if (surprise) { // todo: delete this block eventually
      assert(0, "push surprise oh no")
      // weird recursion happened and we can't go where we wanted to go,
      // even though we just pushed toPush off of that position

      // For consistency with the other inf cases,
      // we should maybe that.die here... that feels bad imo
      // The other inf cases are like hilbert's hotel; this case
      // compresses the crates infinitely, which is no good
      // (any maybe good justification for why they expand back out?
      // so that it looks like nothing happened?)
      console.warn("surprise!", that.serialize(), "->", surprise.serialize())
      that.die()
    }
  }
  assert(numIters === 0 || numIters === 1)
  return r(true)
}
// const maybePushableUpdate = tracer.tracify(maybePushableUpdate_)
const maybePushableUpdate = pushableCached(tracer.tracify(maybePushableUpdate_), cullInfinite)
// ^ this cullInfinite catches the dolphin tutorial

// * if the position/direction we were just at was at a level opening,
//   * (remember, we've already optimistically moved)
// * optimistically teleport out of the mini - new pos is right on top of mini
// * try moving out
function maybeTeleOut_(that, dir) {
  assert(that.frameStack)

  //
  // prep
  //

  const oldPos = that.pos
  const oldFrameStack = that.frameStack
  const oldPFS = player.frameStack
  const r = buildRet(that, ()=>that.playTeleOutSound(), () => {
    that.setPos(oldPos)
    that.setFrameStack(oldFrameStack)
    player.setFrameStack(oldPFS)
  })

  const outPos = innerRoom(that.frameStack).openings()[dir] // the logic near here can be simplified/sped up; prolly doesn't matter tho
  if (!outPos || !outPos.addDir(dir).equals(that.pos)) return r(false)

  //
  // teleport
  //

  let fs = that.frameStack
  let mini = fs.data
  if (mini.constructor === Room) {
    // we've somehow reached the edge of the topmost room
    // (this _is_ possible; e.g. in dup1.lvl)
    return r(false)
  }
  if (that === mini) {
    // TODO: can i merge this with the below frameStack edits?
    console.warn("teleporting out of... myself?")

    spaceRipped = true

    let pfs = player.frameStack
    let nonLoopPart = [that.innerRoom] // create a new frame base
    let sent0 = getSafeSentinel()
    while (sent0()) {
      const { data } = pfs
      if (data === mini) break
      nonLoopPart.push(data)
      pfs = pfs.parent
    }

    nonLoopPart = fromArray(nonLoopPart)
    player.setFrameStack(nonLoopPart)
    console.log("selftele: pfs", serFrame(player.frameStack));

    return r(true)
  }
  that.setPos(mini.pos)
  that.setFrameStack(fs.parent)

  // If we're a mini and we teleported out, edit the player's framestack
  // TODO: ...We should maybe update _everyone's_ frameStack?
  if (that.constructor === Mini) {
    const higherFs = includes(player.frameStack, that)
    if (higherFs) {
      spaceRipped = true

      let pfs = player.frameStack
      let nonLoopPart = []
      let sent3 = getSafeSentinel()
      while (sent3()) {
        const { data } = pfs
        nonLoopPart.push(data)
        if (data === mini) break
        pfs = pfs.parent
      }

      let loopPart = []
      let sent4 = getSafeSentinel()
      while (sent4()) {
        pfs = pfs.parent
        loopPart.push(pfs.data)
        if (equals(pfs, higherFs)) break
      }

      nonLoopPart = fromArray(nonLoopPart, true)
      loopPart = fromArray(loopPart, true)
      player.setFrameStack(concat(nonLoopPart, makeLoop(loopPart)))
    }
  }

  //
  // try to move
  //

  if (maybePushableUpdate(that, dir)) return r(true)

  return r(false)
}
// const maybeTeleOut = pushableCached(tracer.tracify(maybeTeleOut_), cullInfinite)
const maybeTeleOut = tracer.tracify(maybeTeleOut_)

// * if we're standing on a mini,
//   * (remember, we've already optimistically moved)
// * if it has an opening receptive to our direction,
// * optimistically teleport into the mini - one tile before the opening
// * try moving in
function maybeTeleIn_(that, dir) {
  assert(that.frameStack)

  //
  // prep
  //

  const oldPos = that.pos
  const oldFrameStack = that.frameStack
  const oldPFS = player.frameStack
  const r = buildRet(that, ()=>that.playTeleInSound(), () => {
    that.setPos(oldPos)
    that.setFrameStack(oldFrameStack)
    player.setFrameStack(oldPFS)
  })

  const mini = findActorUnderMe(Mini, that)
  if (!mini) return r(false)
  const op = mini.innerRoom.openings()[oppDir(dir)]
  if (!op) return r(false)

  //
  // teleport
  //

  that.setPos(op.addDir(oppDir(dir)))
  that.setFrameStack(cons(mini, that.frameStack))

  // If we're a mini and we teleported in, update the player's frameStack
  // TODO: ...We should maybe update _everyone's_ frameStack?
  if (that.constructor === Mini) {
    const newFs = insertAll(
      player.frameStack,
      m=>m===that,
      mini)
    player.setFrameStack(newFs)
  }

  //
  // try to move
  //

  // `that` has now teleported to an oob-location
  // next to the mini; try to move into the mini
  if (maybePushableUpdate(that, dir)) return r(true)

  return r(false)
}
// const maybeTeleIn = pushableCached(tracer.tracify(maybeTeleIn_), cullInfinite)
const maybeTeleIn = tracer.tracify(maybeTeleIn_)

// * try to tele the food into me
function maybeConsume_(that, food, dir) {
  // dir is the direction the _mini_ is moving
  assert(food.frameStack)
  if (that.constructor !== Mini) return false

  const oldPos = that.pos // might change during e.g. maybetelein; idk
  const oldFrameStack = that.frameStack // might change during e.g. maybeteleout; idk
  const r = buildRet(that, ()=>that.playMoveSound(), () => {
    that.setPos(oldPos)
    that.setFrameStack(oldFrameStack)
  })

  if (!maybeTeleIn(food, oppDir(dir))) return r(false)
  const surprise = findActorUnderMe([Crate, Mini, Player], that)
  if (surprise) { // todo: delete this block eventually
    assert(0, "consume surprise oh no", that.serialize())
    // this is very weird; eating the food has pushed/recursed some stuff
    // around in a way such that the food's old position is occupied again.
    // (e.g. green or purple/yellow room of newpush.lvl)

    // Im so so conflicted about what to do here;
    // I think we should succeed and evaporate the food out of existence
    // That seems to be the case in the green room of newpush.lvl
    // But what about the purple/yellow combo? which block gets eaten?
    // Wouldn't it be all of them but none of them at once? so now the three
    // remaining objects are weird half-and-half glitchy abominations?
    // (could randomize which one is murdered, but that seems like
    // a cop out and a bad experience as a player imo)

    console.warn("infinite nastiness occurs")
    PlayAndRecordSound(sndDestroy)
    // edit: god im playing with it more and everything is so fucky;
    // return false here is no good... but return true isn't great either

    that.die()
  }
  return r(true)
}
// const maybeConsume = tracer.tracify(pushableCached(maybeConsume_, cullInfinite))
const maybeConsume = tracer.tracify(maybeConsume_)

function lifted(lifter, target, cb) {
  // lifts target into lifter's frame, tries to update it in some way (with cb), and unlifts it
  // returns whatever cb returns
  // Might cull lifter if it detects infinity

  // at one point i call this with a fake object with just a frameStack var;
  // don't assume it has anything else pls

  assert(lifter.frameStack)

  if (target.frameStack) {
    // Target has already moved this turn; we must be in an infinite loop
    // The deepest object dies, so bye bye lifter
    return cullInfinite(lifter)
    // ^ this catches the infbug and infbug2 cases
  }
  assert(!target.frameStack)

  target.frameStack = lifter.frameStack
  const success = cb()
  delete target.frameStack

  return success
}
